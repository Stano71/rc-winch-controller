#include <pic12f1840.h>

/*

RA0/ICSPDAT = High side left
RA1/ICSPCLK = High side right
RA2/CCP1  = Low side right (CCP1 for music!)
RA3/Vpp goes to ICSP
RA4 = Low side left
RA5/RX = Servo/UART Input

Music that the controller makes:
- Startup sound
- Off to idle transition
- Idle to off transition

 */

#define MOTOR_OFF   0b00000000
#define MOTOR_BRAKE 0b00010100
#define MOTOR_IN    0b00000101
#define MOTOR_OUT   0b00010010


extern void Init_input(void);
extern void Read_input(void);

enum {
    WINCH_MODE_UNINITIALIZED = 0,
    WINCH_MODE_OFF = 0x30,
    WINCH_MODE_IDLE = 0x31,
    WINCH_MODE_IN = 0x32,
    WINCH_MODE_OUT = 0x33
} winch_mode = WINCH_MODE_UNINITIALIZED;

static unsigned char old_winch_mode = WINCH_MODE_UNINITIALIZED;

static void Init_hardware(void) {
    //-----------------------------
    // Clock initialization
    OSCCON = 0b01111010;    // 4x PLL disabled, 16 MHz HF, Internal oscillator

    //-----------------------------
    // IO Port initialization
    PORTA = 0;
    LATA = 0;
    ANSELA = 0;
    TRISA = 0b11101000;     // Make all ports that are not used for the motor input
    APFCON = 0b10000000;    // Use RA0/RA5 for UART TX/RX, CCP1 or RA2
    
    //-----------------------------
    // Initialize Timer1 for 1 MHz operation
    T1CON = 0b00100000; 
}

static void Process_winch(void) {
    if (winch_mode != old_winch_mode) {
        switch(winch_mode) {
        case WINCH_MODE_OFF:
            LATA = MOTOR_OFF;
            break;
        case WINCH_MODE_IDLE:
            LATA = MOTOR_BRAKE;
            break;
        case WINCH_MODE_IN:
            LATA = MOTOR_IN;
            break;
        case WINCH_MODE_OUT:
            LATA = MOTOR_OUT;
            break;
        default:
            LATA = MOTOR_OFF;
            break;
        }

        old_winch_mode = winch_mode;
    }
}

/* 
    Playing a "song" through the motor.
    
    Single tones are generated by a PWM of 50% at the frequency of the sound.
    A "song" comprises of individual notes, each note has a duration.
    Between notes there can be pauses of a given duration.
    
    Music notes go from 16.35 Hz to 4978.03 Hz according to 
    http://www.phy.mtu.edu/~suits/notefreqs.html
    C3 to C5 (a smaller scale probably is enough) from 130.81 to 523.25 Hz
    Maybe the best is to encode the musical note (there are 12 notes in an 
    octave) and have a table that has pre-calculated timer values for 
    the reqired frequency.
    
    The idea is to use the hardware CCP1 as PWM output with the given duty
    cycle and frequency. For PWM we need to use Timer2.
    However, at 16Mhz Timer2 can not generate low enough frequencies.


    
    Another idea is to use the modulator. Timer 2 would generate a PWM of 25% at
    8 kHz. This 8 kHz would be switched on/off through the modulator at
    the frequency of the sound, using Timer1 presumably. This way of sound 
    generation was observed from the HobbyKing brushed ESC. 
   
    Timer1 is counting up. So we need to preload TMR1H:TMR1L with half the
    desired frequency, and load it in a shadow register accessible 
    from the interrupt.
    Every interrup we toggle the modulator and reload TMR1H:TMR1L

    We can also  use Timer1 to do the duration timing.
    
    130.81 Hz (C3) -> 7645 us period = 3823 us half period
    440 Hz (A4) -> 2273 us period = 1136 us half period
    2093 Hz (C7) -> 478 us period = 239 us half period
    
    If we allow for 4..1020 ms tone / pause durations (8 bits with 4ms resolution) 
    we need to decrement the "tone counter" every 4ms. We can do that reasonably
    accurate by accumulating an 8 bit value with a 16us resolution. So at each
    interrupt we would add the number of "16us units" to our counter. If it 
    overflows we decrement the tone counter. This way we should be able to
    account for reasonably accurate tone durations regardless of the 
    note frequency. 
    
    If we use Timer1 for music we will not be able to output music at the
    same time as measuring a servo pulse. This should not pose an issue
    if the songs we play are short.
  
  
    
    We also could use Timer1 and CCP1 in compare mode. The output pin would
    toggle on match. We need an interrupt to reset the Timer1 so that
    the next period starts again.
    Also tone / pause duration can be calculated in the same way as above.
    This sounds like it is the simplest method, so let's try that first...

    We should run Timer1 with a 1 us clock.    
    For every note we need the 16 bit compare value. We need to also have
    the 16us based increment value (We could calculate that one out of the
    compare value, but a table approach may be simpler).
    
*/

void main(void) {
    Init_hardware();
    Init_input();
    
    while (1) {
        Read_input();
        Process_winch();
    }
}

