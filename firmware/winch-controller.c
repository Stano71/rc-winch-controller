#include <pic12f1840.h>
#include <stdint.h>

static __code uint16_t __at (_CONFIG1) configword1 = _FOSC_INTOSC & _WDTE_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF;
static __code uint16_t __at (_CONFIG2) configword2 = _WRT_OFF & _PLLEN_OFF & _STVREN_OFF & _LVP_OFF; 


/*

Pin 7   RA0/ICSPDAT = High side left
Pin 6   RA1/ICSPCLK = High side right
Pin 5   RA2/CCP1  = Low side right (CCP1 for music!)
Pin 4   RA3/Vpp goes to ICSP
Pin 3   RA4 = Low side left
Pin 2   RA5/RX = Servo/UART Input

Music that the controller makes
===============================
- Startup sound
- Off to idle transition
- Idle to off transition


Playing a "song" through the motor
==================================

Single tones are generated by a PWM of 50% at the frequency of the sound.
A "song" comprises of individual notes, each note has a duration.
Between notes there can be pauses of a given duration.

Music notes go from 16.35 Hz to 4978.03 Hz according to 
http://www.phy.mtu.edu/~suits/notefreqs.html
C3 to C5 (a smaller scale probably is enough) from 130.81 to 523.25 Hz
Maybe the best is to encode the musical note (there are 12 notes in an 
octave) and have a table that has pre-calculated timer values for 
the reqired frequency.

130.81 Hz (C3) -> 7645 us period = 3823 us half period
440 Hz (A4) -> 2273 us period = 1136 us half period
2093 Hz (C7) -> 478 us period = 239 us half period

If we allow for 4..1020 ms tone / pause durations (8 bits with 4ms resolution) 
we need to decrement the "tone counter" every 4ms. We can do that reasonably
accurate by accumulating an 8 bit value with a 16us resolution. So at each
interrupt we would add the number of "16us units" to our counter. If it 
overflows we decrement the tone counter. This way we should be able to
account for reasonably accurate tone durations regardless of the 
note frequency. 

If we use Timer1 for music we will not be able to output music at the
same time as measuring a servo pulse. This should not pose an issue
if the songs we play are short, and we can make the software stop while
the songs are playing.

We use Timer1 and CCP1 in compare mode. CCP1 is set-up to trigger
an interrupt on match and reset the counter. We toggle the output 
in the interrup routine.

We run Timer1 with a 1 us clock. For every note we need the 16 bit compare 
value. We need to also have the 16us based increment value, which
we can easily calculate out of the compare value (divide by 16 is ">> 4").
    
*/

#define MOTOR_OFF   0b00000000
#define MOTOR_BRAKE 0b00010100
#define MOTOR_IN    0b00000101
#define MOTOR_OUT   0b00010010

// Enumeration for notes used in songs
#define C3 0
#define D3 1
#define E3 2
#define F3 3
#define G3 4
#define A3 5
#define B3 6
#define C4 7
#define D4 8
#define E4 9
#define F4 10
#define G4 11
#define A4 12
#define B4 13
#define C5 14

// Frequencies for each notes in Hz
// Source: http://www.phy.mtu.edu/~suits/notefreqs.html
#define F_C3 130.81
#define F_D3 146.83
#define F_E3 164.81
#define F_F3 174.61
#define F_G3 196.00
#define F_A3 220.00
#define F_B3 246.94
#define F_C4 261.63
#define F_D4 293.66
#define F_E4 329.63
#define F_F4 349.23
#define F_G4 392.00
#define F_A4 440.00
#define F_B4 493.88
#define F_C5 523.25


extern void Init_input(void);
extern void Read_input(void);

enum {
    WINCH_MODE_UNINITIALIZED = 0,
    WINCH_MODE_OFF = 0x30,
    WINCH_MODE_IDLE = 0x31,
    WINCH_MODE_IN = 0x32,
    WINCH_MODE_OUT = 0x33
} winch_mode = WINCH_MODE_UNINITIALIZED;

static unsigned char old_winch_mode = WINCH_MODE_UNINITIALIZED;

// Tables to look up the CCP1 compare values for a given note. High byte
// and low byte have a separate table for simplicity sake.
__code unsigned char notes_high[] = {
    ((unsigned int) (500000 / F_C3)) >> 8,
    ((unsigned int) (500000 / F_D3)) >> 8,
    ((unsigned int) (500000 / F_E3)) >> 8,
    ((unsigned int) (500000 / F_F3)) >> 8,
    ((unsigned int) (500000 / F_G3)) >> 8,
    ((unsigned int) (500000 / F_A3)) >> 8,
    ((unsigned int) (500000 / F_B3)) >> 8,
    ((unsigned int) (500000 / F_C4)) >> 8,
    ((unsigned int) (500000 / F_D4)) >> 8,
    ((unsigned int) (500000 / F_E4)) >> 8,
    ((unsigned int) (500000 / F_F4)) >> 8,
    ((unsigned int) (500000 / F_G4)) >> 8,
    ((unsigned int) (500000 / F_A4)) >> 8,
    ((unsigned int) (500000 / F_B4)) >> 8,
    ((unsigned int) (500000 / F_C5)) >> 8
};

__code unsigned char notes_low[] = {
    ((unsigned int) (500000 / F_C3)),
    ((unsigned int) (500000 / F_D3)),
    ((unsigned int) (500000 / F_E3)),
    ((unsigned int) (500000 / F_F3)),
    ((unsigned int) (500000 / F_G3)),
    ((unsigned int) (500000 / F_A3)),
    ((unsigned int) (500000 / F_B3)),
    ((unsigned int) (500000 / F_C4)),
    ((unsigned int) (500000 / F_D4)),
    ((unsigned int) (500000 / F_E4)),
    ((unsigned int) (500000 / F_F4)),
    ((unsigned int) (500000 / F_G4)),
    ((unsigned int) (500000 / F_A4)),
    ((unsigned int) (500000 / F_B4)),
    ((unsigned int) (500000 / F_C5))
};


void Intr(void) __interrupt 0
{
//    T0IF = 0; /* Clear timer interrupt */
    CCP1IF = 0;
    if (LATA2)
        LATA2 = 0;
    else
        LATA2 = 1;
    
}


static void Init_hardware(void) {
    //-----------------------------
    // Clock initialization
    OSCCON = 0b01111010;    // 4x PLL disabled, 16 MHz HF, Internal oscillator

    //-----------------------------
    // IO Port initialization
    PORTA = 0;
    LATA = 0;
    ANSELA = 0;
    TRISA = 0b11101000;     // Make all ports that are not used for the motor input
    APFCON = 0b10000000;    // Use RA0/RA5 for UART TX/RX, CCP1 on RA2
    
    //-----------------------------
    // Initialize Timer1 for 1 MHz operation
    T1CON = 0b00100000; 

    CCPR1H = 1136 >> 8;
    CCPR1L = 1136 & 0xff;
    CCP1CON = 0b00001011; // Compare mode: special event trigger
    
    TMR1ON = 1;
    CCP1IE = 1;
    PEIE = 1;
    GIE = 1;


}


static void Process_winch(void) {
    if (winch_mode != old_winch_mode) {
        switch(winch_mode) {
        case WINCH_MODE_OFF:
            LATA = MOTOR_OFF;
            break;
        case WINCH_MODE_IDLE:
            LATA = MOTOR_BRAKE;
            break;
        case WINCH_MODE_IN:
            LATA = MOTOR_IN;
            break;
        case WINCH_MODE_OUT:
            LATA = MOTOR_OUT;
            break;
        default:
            LATA = MOTOR_OFF;
            break;
        }

        old_winch_mode = winch_mode;
    }
}


void Play_song(unsigned char song) {
    
}


void main(void) {
    Init_hardware();
//    Init_input();
    
    while (1) {
        CCPR1H = notes_high[G3];
        CCPR1L = notes_low[G3];
        
        // Note duration in 16 us units
        old_winch_mode =  (notes_high[G3] << 4) + (notes_low[G3] >> 4);
        
        LATA0 = 1;
        LATA1 = 1;
        //LATA2 = 1;
        LATA4 = 1;
        
        LATA0 = 0;
        LATA1 = 0;
        //LATA2 = 0;
        LATA4 = 0;
        
        //Read_input();
        //Process_winch();
    }
}




